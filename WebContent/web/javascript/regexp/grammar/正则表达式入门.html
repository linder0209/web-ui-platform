<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>正则表达式——正则表达式入门</title>
        <link rel="stylesheet" href="../../../../platform/css/base.css" type="text/css"/>
        <link rel="stylesheet" href="../../../../platform/css/platform.css" type="text/css"/>
        <link rel="stylesheet" href="../../../../platform/css/theme/skyblue.css" type="text/css"/>
        <link rel="stylesheet" href="../../../../platform/css/web.css" type="text/css"/>
    </head>
    <body>
        <h3 class="h-web-paragraph-title">目录</h3>
        <ol class="h-web-catalogue">
            <li><a href="">什么是正则表达式</a></li>
            <li><a href="">正则表达式常用的21个元字符</a></li>
        </ol>
        <div class="h-web-paragraph">
            <h3 class="h-web-paragraph-title">什么是正则表达式</h3>
            <p>在计算机科学中，是指一个用来描述或者匹配一系列符合某个句法规则的字符串。在很多文本编辑器或其他工具里，正则表达式通常被用来检索和/或替换那些符合某个模式的文本内容。许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在Perl中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由Unix中的工具软件（例如sed和grep）普及开的。正则表达式通常缩写成&ldquo;regex&rdquo;，单数有regexp、regex，复数有regexps、regexes、regexen。

            </p>
            <h3 class="h-web-paragraph-title">正则表达式常用的21个元字符</h3>
            <p>df</p>
            <h4>\b 元字符</h4>
          <p>\b是正则表达式规定的一个特殊代码，代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\b并不匹配这些单词分隔字符中的任何一个，它<strong>只匹配一个位置</strong>。</p>
          <p>如果需要更精确的说法，\b匹配这样的位置：它的前一个字符和后一个字符不全是(一个是,一个不是或不存在)\w。</p>
            <p>假如你要找的是hi后面不远处跟着一个Lucy，你应该用\bhi\b.*\bLucy\b。</p>
            <p>例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。</p>
            <h4>^ 元字符和$元字符</h4>
            <p>^匹配输入字符串的开始位置。如果设置了 <strong>RegExp</strong> 对象的 <strong>Multiline</strong> 属性，^ 也匹配 '\n' 或 '\r'   之后的位置。</p>
            <p>$匹配输入字符串的结束位置。如果设置了<strong>RegExp</strong> 对象的 <strong>Multiline</strong> 属性，$ 也匹配 '\n' 或 '\r' 之前的位置。</p>
            <p>元字符^和$都匹配一个位置，这和\b有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：^\d{5,12}$。            </p>
            <p>因为使用了^和$，所以输入的整个字符串都要用来和\d{5,12}来匹配，也就是说整个输入必须是5到12个数字，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。</p>
            <p>如果设置了<strong>Multiline</strong> 属性，^和$的意义就变成了匹配行的开始处和结束处。</p>
            <h4>字符数字类元字符</h4>
            <p>字符数字类包括\w、\d和\s </p>
          <h4>\w元字符</h4>
            <p>匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。 </p>
            <p>例子：</p>
            <p>\ba\w*\b匹配以字母a开头的单词——先是某个单词开始处(\b)，然后是字母a,然后是任意数量的字母或数字(\w*)，最后是单词结束处(\b)。            </p>
            <p>\b\w{6}\b 匹配刚好6个字符的单词。</p>
            <h4>\d元字符</h4>
            <p>匹配一个数字字符。等价于 [0-9]。 例如：\d+指匹配一个或多个数字。</p>
            <h4>\s元字符</h4>
            <p>匹配任何空白字符，包括空格、制表符、换页符、中文全角空格等等。等价于 [ \f\n\r\t\v]。例如：\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty。关于该例子的解释，后向引用中会说明。</p>
            <h4>重复元字符</h4>
            <table>
              <caption>
                常用的重复限定符
              </caption>
              <thead>
                <tr>
                  <th scope="col">代码/语法</th>
                  <th scope="col">说明</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>*</td>
                  <td>匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。 * 等价于{0,}。</td>
                </tr>
                <tr>
                  <td>+</td>
                  <td>匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。</td>
                </tr>
                <tr>
                  <td>?</td>
                  <td>匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 中的"do" 。? 等价于 {0,1}。</td>
                </tr>
                <tr>
                  <td>{n}</td>
                  <td><em>n</em> 是一个非负整数。匹配确定的 <em>n</em> 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个   o。</td>
                </tr>
                <tr>
                  <td>{n,}</td>
                  <td><em>n</em> 是一个非负整数。至少匹配<em>n</em> 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有   o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。</td>
                </tr>
                <tr>
                  <td>{n,m}</td>
                  <td><em>m</em> 和 <em>n</em> 均为非负整数，其中<em>n</em> &lt;= <em>m</em>。最少匹配 <em>n</em> 次且最多匹配 <em>m</em> 次。刘， "o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于   'o?'。请注意在逗号和两个数之间不能有空格。</td>
                </tr>
              </tbody>
            </table>
          <p>下面是一些使用重复的例子：</p>
            <p>Windows\d+匹配Windows后面跟1个或更多数字</p>
          <p>^\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)</p>
            <h4>分支条件、分组和字符集合元字符</h4>
            <p>首先看分支条件|元字符，先看例子，如果我们想要匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。可以这样写正则表达式，\(?0\d{2}[) -]?\d{8}。我们对它进行一些分析吧：首先是一个转义字符\(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\d{8})。</p>
            <p>不幸的是，刚才那个表达式也能匹配010)12345678或(022-87654321这样的&ldquo;不正确&rdquo;的格式。要解决这个问题，我们需要用到分支条件。正则表达式里的分支条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。正确的写法应该是：\(0\d{2,3}\)[- ]?\d{8}|0\d{2,3}[- ]?\d{8}这个表达式匹配3位区号或四位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。</p>
            <p>\d{5}-\d{4}|\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：<strong>使用分支条件时，要注意各个条件的顺序</strong>。如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分支条件时，将会从左到右地测试每个条件，如果满足了某个分支的话，就不会去再管其它的条件了。</p>
            <p>&nbsp;</p>
        </div>
    </body>
</html>